generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model User {
  id                   Int                   @id @default(autoincrement())
  email                String                @unique
  username             String                @unique
  password             String
  isVerified           Boolean               @default(false)
  otp                  String?
  otpExpiresAt         DateTime?
  newEmail             String?               // Temporary field to store new email during change process
  createdAt            DateTime              @default(now())
  updatedAt            DateTime              @updatedAt
  refreshTokens        RefreshToken[]
  blogPosts            BlogPost[]
  teamMembers          TeamMember[]
  executiveLeadership  ExecutiveLeadership[]

  @@map("users")
}

model RefreshToken {
  id         Int      @id @default(autoincrement())
  token      String   @unique
  expiresAt  DateTime
  revoked    Boolean  @default(false)
  rememberMe Boolean  @default(false)
  userId     Int
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId], map: "refresh_tokens_userId_fkey")
  @@map("refresh_tokens")
}

model BlogPost {
  id            Int      @id @default(autoincrement())
  title         String
  description   String   @db.Text
  content       String   @db.Text
  category      String
  readTime      String?
  authorName    String
  authorPosition String?
  authorImage   String?
  blogImage     String?
  published     Boolean  @default(false)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  userId        Int
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId], map: "blog_posts_userId_fkey")
  @@index([published], map: "blog_posts_published_idx")
  @@index([category], map: "blog_posts_category_idx")
  @@map("blog_posts")
}

model TeamMember {
  id            Int      @id @default(autoincrement())
  name          String
  position      String
  description   String   @db.Text
  image         String?  // Store only the image filename, not full URL
  department    String?
  isActive      Boolean  @default(true)
  displayOrder  Int      @default(1) // For ordering team members (minimum 1)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  userId        Int
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId], map: "team_members_userId_fkey")
  @@index([isActive], map: "team_members_isActive_idx")
  @@index([displayOrder], map: "team_members_displayOrder_idx")
  @@map("team_members")
}

model ExecutiveLeadership {
  id            Int      @id @default(autoincrement())
  name          String
  position      String
  description   String   @db.Text
  image         String?  // Store only the image filename, not full URL
  linkedinUrl   String?
  twitterUrl    String?
  isActive      Boolean  @default(true)
  displayOrder  Int      @default(1) // For ordering executive leadership (minimum 1)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  userId        Int
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId], map: "executive_leadership_userId_fkey")
  @@index([isActive], map: "executive_leadership_isActive_idx")
  @@index([displayOrder], map: "executive_leadership_displayOrder_idx")
  @@map("executive_leadership")
}